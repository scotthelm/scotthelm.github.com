<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>New Rails App With Docker | Scott Helm</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="New Rails App With Docker" />
<meta name="author" content="Scott Helm" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="There are a ton of posts out there on this topic. The purpose of this post is to show the step-by-step creation of a new dockerized rails application, hooked up to postgres. The next article in the series will show how to set up rspec and guard for your testing pleasure, and the final article in the series will highlight some tools that make development in docker an even more enjoyable experience. Prerequisites In order to follow along, you will need to install docker on your system. For Mac and Windows, this link will get you started. If you are in a linux environment, you will need: Docker Docker Machine Docker Compose Come back once you get it installed. I’ll wait. Getting Started Cool. The first thing we’ll need is an empty directory. In order for mounted volumes to play nicely, you’ll need to create this directory somewhere in your home folder: ~/development $ mkdir myapp ~/development $ cd myapp ##The Gemfile The next thing we’ll need is a Gemfile. This is where we’ll start setting up our development environment. # frozen_string_literal: true source &#39;https://rubygems.org&#39; gem &#39;rails&#39; group :development, :test do gem &#39;rspec-rails&#39; gem &#39;guard-rspec&#39; gem &#39;rubocop&#39; end ##The Dockerfile Now that we have a Gemfile, we can start building our docker image. Docker works on the principal of linux containers, and uses a layered file system. A docker image is like a photoshop image. You start with a base layer (in this case, it’s ruby:latest) and then we start layering our changes on top of it. Every command you see in the Dockerfile changes the file system in some way. Docker responds to this by creating another layer on top of the base image. In our first iteration of the Dockerfile, we specify that we want Ruby 2.3.1, and that we want our code to live in /usr/src/app. We set our working directory to that location and copy our gemfile into it. FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . The docker-compose.yml This file describes the services in our application. This will be an iterative process to build our application step-by step. Doing it this way, we don’t even have to have ruby installed on our system. The Docker image handles that for us. version: &quot;2&quot; services: app: context: build: . dockerfile: Dockerfile volumes: - .:/usr/src/app This file lets us specify that we have a service called app. We want to build an image for app using the current directory as the contents to layer on top of the base image. We want to use the Dockerfile that we created earlier, and we want to mount our current directory (in this case: ~/development/myapp) to the /user/src/app directory in the container. We’ll get into the difference between an Docker image and a Docker container later. Building our app image So now that we have the rough-in of our plumbing done, we should be able to build the Docker image for our app. We can do this by using docker-compose: ~/development/myapp $ docker-compose build We should get some output like this (yours will probably need to pull the ruby base image down, so you will see some progress bars as this happens). Building app Step 1 : FROM ruby:2.3.1 ---&gt; 316ceaa79560 Step 2 : WORKDIR /usr/src/app ---&gt; Running in 64c2cf1a6324 ---&gt; f677d3669a90 Removing intermediate container 64c2cf1a6324 Step 3 : COPY Gemfile . ---&gt; 64cd3ad6bf21 Removing intermediate container 6b71f68d3fc7 Successfully built 64cd3ad6bf21 We now have a Docker image of our app that has our Gemfile in it. Now we need to install the gems. Running our first container You can think of the difference between an image and a container much like the difference between a class and an instance of a class. The image is the class. It is a full filesystem, and it has everthing needed for running your ruby process. However, it’s static. It is an image of a running system. The running system is a container. The container uses the image to run a single process. When that process ends, so does the container. Poetic, really. The first thing we are going to do is run a bash session so we can bundle our gems. Because our current directory is mounted as the volume /usr/src/app in the container, changes to that directory in the container are reflected in our host system. The --rm indicates that we want to remove the app container when the bash process ends. ~/development/myapp $ docker-compose run --rm app /bin/bash You should now be at a prompt as root in your new container: Creating network &quot;myapp_default&quot; with the default driver root@ff372d086cd0:/usr/src/app# Here, we will run root@ff372d086cd0:/usr/src/app# bundle install This will install the gems from our Gemfile and create a new Gemfile.lock in the container AND on our host system. You should get the usual bundler output. type exit at the prompt and you should be back on the host system. If you ls you should now see a new file: Gemfile.lock Dockerfile Part Deux Now that we have a Gemfile.lock, we need to get that into our image. Additionally, we need to install the gems into the image. To do this, we need to modify our Dockerfile so the image has everything our container needs in order to install our rails app. The new dockerfile should look like this: FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . COPY Gemfile.lock . RUN bundle install Now we need to run ~/development/myapp $ docker-compose build again. This will install the gems into the image, and allow us to use them when we launch the image as a container docker-compose.yml Part Deux We want to mimic our production environment, so we want to use Postgresql as our database. Turns out, Postgresql has an official image that we can use - so let’s add it as a service and link it to our app in our docker-compose.yml file: version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db db: image: postgres:9.5.3 Installing Rails Start a new container using ~/development/myapp $ docker-compose run --rm app /bin/bash Now that we’re back inside the container, we can install rails with Postgres as the database, and skipping tests (we’ll set up rspec in a minute): root@5ff8a0519772:/usr/src/app# rails new -T --database=postgresql . You’ll be prompted to overwrite your Gemfile…type Y. You’ll also be warned not to run bundler as root. Ignore that since this is a container, and the only user is root! Once that’s done, you can exit out of the container, and you should have all the files for a new Rails application in your host directory. There’s a couple of other modifications we’ll need to make. We’ll need a javascript runtime, so we can uncomment gem &#39;therubyracer&#39; in the Gemfile. Wel’ll also need to set up our database connections in our config/database.yml file: development: &lt;&lt;: *default host: db database: &lt;%= ENV[&#39;RAILS_DATABASE_NAME&#39;] %&gt; username: &lt;%= ENV[&#39;RAILS_DATABASE_USER&#39;] %&gt; password: &lt;%= ENV[&#39;RAILS_DATABASE_PASSWORD&#39;] %&gt; test: &lt;&lt;: *default host: db database: &lt;%= ENV[&#39;RAILS_TEST_DATABASE_NAME&#39;] %&gt; username: &lt;%= ENV[&#39;RAILS_DATABASE_USER&#39;] %&gt; password: &lt;%= ENV[&#39;RAILS_DATABASE_PASSWORD&#39;] %&gt; “Wait…” I hear you say. “Where do those environment variables come from?” I’m glad you asked: Environment Variables The easiest way to accomplish this is with a .env file. This file can be git ignored so it never hits your remote repo, but still has your super secret username/password stuff. It has this format: RAILS_DATABASE_NAME=app RAILS_TEST_DATABASE_NAME=app_test RAILS_DATABASE_USER=postgres RAILS_DATABASE_PASSWORD= To use it we need to modify our docker-compose.yml again version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db env_file: .env db: image: postgres:9.5.3 Safety Third If you haven’t already…Now is probably a good time to git init and make your initial commit. Dockerfile Part The-One-After-Deux Installing rails modified our Gemfile and Gemfile.lock. It also added all the files for a rails app - so we need to build the new image. In order to do that, our new Dockerfile should look like this: FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . COPY Gemfile.lock . RUN bundle install COPY . /usr/src/app now build it again ~/development/myapp $ docker-compose build Starting Postgres The first thing we need to do is create our database. In order to do that, we’re going to start our postgresql container thusly: ~/development/myapp $ docker-compose up -d db This command starts a postgres container in the background (-d) as defined by our db: service in our docker-compose.yml Creating The Database Now that we have a running postgres instance, we can create our development and test databases ~/development/myapp $ docker-compose run --rm app rake db:create If all goes well, it should simply return. On repeat invocations, you should get the following output: ~/development/myapp $ docker-compose run --rm app rake db:create app already exists app_test already exists ##Running The App To do this, we’re going to need to add a command and open some ports to our app: container. To do that, we’re going to modify our docker-compose file again: version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db env_file: .env command: rails s -p 3000 -b 0.0.0.0 ports: - &quot;3000:3000&quot; db: image: postgres:9.5.3 This starts a server when we bring the container up, it also exposes port 3000 all the way to the host machine. To start the server, we run ~/development/myapp $ docker-compose up -d To find out where the app is running, you can use ~/development/myapp $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS default * virtualbox Running tcp://192.168.99.100:2376 v1.10.2 ~/development/myapp $ docker-machine env default export DOCKER_TLS_VERIFY=&quot;1&quot; export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; export DOCKER_CERT_PATH=&quot;/Users/Scott/.docker/machine/machines/default&quot; export DOCKER_MACHINE_NAME=&quot;default&quot; That docker host ip is what we’re interested in. Now you should be able to open your browser to http://192.168.99.100:300 and see that lovely new rails app page. Next Time… The next article will be all about setting up rspec and guard" />
<meta property="og:description" content="There are a ton of posts out there on this topic. The purpose of this post is to show the step-by-step creation of a new dockerized rails application, hooked up to postgres. The next article in the series will show how to set up rspec and guard for your testing pleasure, and the final article in the series will highlight some tools that make development in docker an even more enjoyable experience. Prerequisites In order to follow along, you will need to install docker on your system. For Mac and Windows, this link will get you started. If you are in a linux environment, you will need: Docker Docker Machine Docker Compose Come back once you get it installed. I’ll wait. Getting Started Cool. The first thing we’ll need is an empty directory. In order for mounted volumes to play nicely, you’ll need to create this directory somewhere in your home folder: ~/development $ mkdir myapp ~/development $ cd myapp ##The Gemfile The next thing we’ll need is a Gemfile. This is where we’ll start setting up our development environment. # frozen_string_literal: true source &#39;https://rubygems.org&#39; gem &#39;rails&#39; group :development, :test do gem &#39;rspec-rails&#39; gem &#39;guard-rspec&#39; gem &#39;rubocop&#39; end ##The Dockerfile Now that we have a Gemfile, we can start building our docker image. Docker works on the principal of linux containers, and uses a layered file system. A docker image is like a photoshop image. You start with a base layer (in this case, it’s ruby:latest) and then we start layering our changes on top of it. Every command you see in the Dockerfile changes the file system in some way. Docker responds to this by creating another layer on top of the base image. In our first iteration of the Dockerfile, we specify that we want Ruby 2.3.1, and that we want our code to live in /usr/src/app. We set our working directory to that location and copy our gemfile into it. FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . The docker-compose.yml This file describes the services in our application. This will be an iterative process to build our application step-by step. Doing it this way, we don’t even have to have ruby installed on our system. The Docker image handles that for us. version: &quot;2&quot; services: app: context: build: . dockerfile: Dockerfile volumes: - .:/usr/src/app This file lets us specify that we have a service called app. We want to build an image for app using the current directory as the contents to layer on top of the base image. We want to use the Dockerfile that we created earlier, and we want to mount our current directory (in this case: ~/development/myapp) to the /user/src/app directory in the container. We’ll get into the difference between an Docker image and a Docker container later. Building our app image So now that we have the rough-in of our plumbing done, we should be able to build the Docker image for our app. We can do this by using docker-compose: ~/development/myapp $ docker-compose build We should get some output like this (yours will probably need to pull the ruby base image down, so you will see some progress bars as this happens). Building app Step 1 : FROM ruby:2.3.1 ---&gt; 316ceaa79560 Step 2 : WORKDIR /usr/src/app ---&gt; Running in 64c2cf1a6324 ---&gt; f677d3669a90 Removing intermediate container 64c2cf1a6324 Step 3 : COPY Gemfile . ---&gt; 64cd3ad6bf21 Removing intermediate container 6b71f68d3fc7 Successfully built 64cd3ad6bf21 We now have a Docker image of our app that has our Gemfile in it. Now we need to install the gems. Running our first container You can think of the difference between an image and a container much like the difference between a class and an instance of a class. The image is the class. It is a full filesystem, and it has everthing needed for running your ruby process. However, it’s static. It is an image of a running system. The running system is a container. The container uses the image to run a single process. When that process ends, so does the container. Poetic, really. The first thing we are going to do is run a bash session so we can bundle our gems. Because our current directory is mounted as the volume /usr/src/app in the container, changes to that directory in the container are reflected in our host system. The --rm indicates that we want to remove the app container when the bash process ends. ~/development/myapp $ docker-compose run --rm app /bin/bash You should now be at a prompt as root in your new container: Creating network &quot;myapp_default&quot; with the default driver root@ff372d086cd0:/usr/src/app# Here, we will run root@ff372d086cd0:/usr/src/app# bundle install This will install the gems from our Gemfile and create a new Gemfile.lock in the container AND on our host system. You should get the usual bundler output. type exit at the prompt and you should be back on the host system. If you ls you should now see a new file: Gemfile.lock Dockerfile Part Deux Now that we have a Gemfile.lock, we need to get that into our image. Additionally, we need to install the gems into the image. To do this, we need to modify our Dockerfile so the image has everything our container needs in order to install our rails app. The new dockerfile should look like this: FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . COPY Gemfile.lock . RUN bundle install Now we need to run ~/development/myapp $ docker-compose build again. This will install the gems into the image, and allow us to use them when we launch the image as a container docker-compose.yml Part Deux We want to mimic our production environment, so we want to use Postgresql as our database. Turns out, Postgresql has an official image that we can use - so let’s add it as a service and link it to our app in our docker-compose.yml file: version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db db: image: postgres:9.5.3 Installing Rails Start a new container using ~/development/myapp $ docker-compose run --rm app /bin/bash Now that we’re back inside the container, we can install rails with Postgres as the database, and skipping tests (we’ll set up rspec in a minute): root@5ff8a0519772:/usr/src/app# rails new -T --database=postgresql . You’ll be prompted to overwrite your Gemfile…type Y. You’ll also be warned not to run bundler as root. Ignore that since this is a container, and the only user is root! Once that’s done, you can exit out of the container, and you should have all the files for a new Rails application in your host directory. There’s a couple of other modifications we’ll need to make. We’ll need a javascript runtime, so we can uncomment gem &#39;therubyracer&#39; in the Gemfile. Wel’ll also need to set up our database connections in our config/database.yml file: development: &lt;&lt;: *default host: db database: &lt;%= ENV[&#39;RAILS_DATABASE_NAME&#39;] %&gt; username: &lt;%= ENV[&#39;RAILS_DATABASE_USER&#39;] %&gt; password: &lt;%= ENV[&#39;RAILS_DATABASE_PASSWORD&#39;] %&gt; test: &lt;&lt;: *default host: db database: &lt;%= ENV[&#39;RAILS_TEST_DATABASE_NAME&#39;] %&gt; username: &lt;%= ENV[&#39;RAILS_DATABASE_USER&#39;] %&gt; password: &lt;%= ENV[&#39;RAILS_DATABASE_PASSWORD&#39;] %&gt; “Wait…” I hear you say. “Where do those environment variables come from?” I’m glad you asked: Environment Variables The easiest way to accomplish this is with a .env file. This file can be git ignored so it never hits your remote repo, but still has your super secret username/password stuff. It has this format: RAILS_DATABASE_NAME=app RAILS_TEST_DATABASE_NAME=app_test RAILS_DATABASE_USER=postgres RAILS_DATABASE_PASSWORD= To use it we need to modify our docker-compose.yml again version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db env_file: .env db: image: postgres:9.5.3 Safety Third If you haven’t already…Now is probably a good time to git init and make your initial commit. Dockerfile Part The-One-After-Deux Installing rails modified our Gemfile and Gemfile.lock. It also added all the files for a rails app - so we need to build the new image. In order to do that, our new Dockerfile should look like this: FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . COPY Gemfile.lock . RUN bundle install COPY . /usr/src/app now build it again ~/development/myapp $ docker-compose build Starting Postgres The first thing we need to do is create our database. In order to do that, we’re going to start our postgresql container thusly: ~/development/myapp $ docker-compose up -d db This command starts a postgres container in the background (-d) as defined by our db: service in our docker-compose.yml Creating The Database Now that we have a running postgres instance, we can create our development and test databases ~/development/myapp $ docker-compose run --rm app rake db:create If all goes well, it should simply return. On repeat invocations, you should get the following output: ~/development/myapp $ docker-compose run --rm app rake db:create app already exists app_test already exists ##Running The App To do this, we’re going to need to add a command and open some ports to our app: container. To do that, we’re going to modify our docker-compose file again: version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db env_file: .env command: rails s -p 3000 -b 0.0.0.0 ports: - &quot;3000:3000&quot; db: image: postgres:9.5.3 This starts a server when we bring the container up, it also exposes port 3000 all the way to the host machine. To start the server, we run ~/development/myapp $ docker-compose up -d To find out where the app is running, you can use ~/development/myapp $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS default * virtualbox Running tcp://192.168.99.100:2376 v1.10.2 ~/development/myapp $ docker-machine env default export DOCKER_TLS_VERIFY=&quot;1&quot; export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; export DOCKER_CERT_PATH=&quot;/Users/Scott/.docker/machine/machines/default&quot; export DOCKER_MACHINE_NAME=&quot;default&quot; That docker host ip is what we’re interested in. Now you should be able to open your browser to http://192.168.99.100:300 and see that lovely new rails app page. Next Time… The next article will be all about setting up rspec and guard" />
<link rel="canonical" href="/2016/06/07/new-rails-app-with-docker.html" />
<meta property="og:url" content="/2016/06/07/new-rails-app-with-docker.html" />
<meta property="og:site_name" content="Scott Helm" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-06-07T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="New Rails App With Docker" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Scott Helm"},"dateModified":"2016-06-07T00:00:00-04:00","datePublished":"2016-06-07T00:00:00-04:00","description":"There are a ton of posts out there on this topic. The purpose of this post is to show the step-by-step creation of a new dockerized rails application, hooked up to postgres. The next article in the series will show how to set up rspec and guard for your testing pleasure, and the final article in the series will highlight some tools that make development in docker an even more enjoyable experience. Prerequisites In order to follow along, you will need to install docker on your system. For Mac and Windows, this link will get you started. If you are in a linux environment, you will need: Docker Docker Machine Docker Compose Come back once you get it installed. I’ll wait. Getting Started Cool. The first thing we’ll need is an empty directory. In order for mounted volumes to play nicely, you’ll need to create this directory somewhere in your home folder: ~/development $ mkdir myapp ~/development $ cd myapp ##The Gemfile The next thing we’ll need is a Gemfile. This is where we’ll start setting up our development environment. # frozen_string_literal: true source &#39;https://rubygems.org&#39; gem &#39;rails&#39; group :development, :test do gem &#39;rspec-rails&#39; gem &#39;guard-rspec&#39; gem &#39;rubocop&#39; end ##The Dockerfile Now that we have a Gemfile, we can start building our docker image. Docker works on the principal of linux containers, and uses a layered file system. A docker image is like a photoshop image. You start with a base layer (in this case, it’s ruby:latest) and then we start layering our changes on top of it. Every command you see in the Dockerfile changes the file system in some way. Docker responds to this by creating another layer on top of the base image. In our first iteration of the Dockerfile, we specify that we want Ruby 2.3.1, and that we want our code to live in /usr/src/app. We set our working directory to that location and copy our gemfile into it. FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . The docker-compose.yml This file describes the services in our application. This will be an iterative process to build our application step-by step. Doing it this way, we don’t even have to have ruby installed on our system. The Docker image handles that for us. version: &quot;2&quot; services: app: context: build: . dockerfile: Dockerfile volumes: - .:/usr/src/app This file lets us specify that we have a service called app. We want to build an image for app using the current directory as the contents to layer on top of the base image. We want to use the Dockerfile that we created earlier, and we want to mount our current directory (in this case: ~/development/myapp) to the /user/src/app directory in the container. We’ll get into the difference between an Docker image and a Docker container later. Building our app image So now that we have the rough-in of our plumbing done, we should be able to build the Docker image for our app. We can do this by using docker-compose: ~/development/myapp $ docker-compose build We should get some output like this (yours will probably need to pull the ruby base image down, so you will see some progress bars as this happens). Building app Step 1 : FROM ruby:2.3.1 ---&gt; 316ceaa79560 Step 2 : WORKDIR /usr/src/app ---&gt; Running in 64c2cf1a6324 ---&gt; f677d3669a90 Removing intermediate container 64c2cf1a6324 Step 3 : COPY Gemfile . ---&gt; 64cd3ad6bf21 Removing intermediate container 6b71f68d3fc7 Successfully built 64cd3ad6bf21 We now have a Docker image of our app that has our Gemfile in it. Now we need to install the gems. Running our first container You can think of the difference between an image and a container much like the difference between a class and an instance of a class. The image is the class. It is a full filesystem, and it has everthing needed for running your ruby process. However, it’s static. It is an image of a running system. The running system is a container. The container uses the image to run a single process. When that process ends, so does the container. Poetic, really. The first thing we are going to do is run a bash session so we can bundle our gems. Because our current directory is mounted as the volume /usr/src/app in the container, changes to that directory in the container are reflected in our host system. The --rm indicates that we want to remove the app container when the bash process ends. ~/development/myapp $ docker-compose run --rm app /bin/bash You should now be at a prompt as root in your new container: Creating network &quot;myapp_default&quot; with the default driver root@ff372d086cd0:/usr/src/app# Here, we will run root@ff372d086cd0:/usr/src/app# bundle install This will install the gems from our Gemfile and create a new Gemfile.lock in the container AND on our host system. You should get the usual bundler output. type exit at the prompt and you should be back on the host system. If you ls you should now see a new file: Gemfile.lock Dockerfile Part Deux Now that we have a Gemfile.lock, we need to get that into our image. Additionally, we need to install the gems into the image. To do this, we need to modify our Dockerfile so the image has everything our container needs in order to install our rails app. The new dockerfile should look like this: FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . COPY Gemfile.lock . RUN bundle install Now we need to run ~/development/myapp $ docker-compose build again. This will install the gems into the image, and allow us to use them when we launch the image as a container docker-compose.yml Part Deux We want to mimic our production environment, so we want to use Postgresql as our database. Turns out, Postgresql has an official image that we can use - so let’s add it as a service and link it to our app in our docker-compose.yml file: version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db db: image: postgres:9.5.3 Installing Rails Start a new container using ~/development/myapp $ docker-compose run --rm app /bin/bash Now that we’re back inside the container, we can install rails with Postgres as the database, and skipping tests (we’ll set up rspec in a minute): root@5ff8a0519772:/usr/src/app# rails new -T --database=postgresql . You’ll be prompted to overwrite your Gemfile…type Y. You’ll also be warned not to run bundler as root. Ignore that since this is a container, and the only user is root! Once that’s done, you can exit out of the container, and you should have all the files for a new Rails application in your host directory. There’s a couple of other modifications we’ll need to make. We’ll need a javascript runtime, so we can uncomment gem &#39;therubyracer&#39; in the Gemfile. Wel’ll also need to set up our database connections in our config/database.yml file: development: &lt;&lt;: *default host: db database: &lt;%= ENV[&#39;RAILS_DATABASE_NAME&#39;] %&gt; username: &lt;%= ENV[&#39;RAILS_DATABASE_USER&#39;] %&gt; password: &lt;%= ENV[&#39;RAILS_DATABASE_PASSWORD&#39;] %&gt; test: &lt;&lt;: *default host: db database: &lt;%= ENV[&#39;RAILS_TEST_DATABASE_NAME&#39;] %&gt; username: &lt;%= ENV[&#39;RAILS_DATABASE_USER&#39;] %&gt; password: &lt;%= ENV[&#39;RAILS_DATABASE_PASSWORD&#39;] %&gt; “Wait…” I hear you say. “Where do those environment variables come from?” I’m glad you asked: Environment Variables The easiest way to accomplish this is with a .env file. This file can be git ignored so it never hits your remote repo, but still has your super secret username/password stuff. It has this format: RAILS_DATABASE_NAME=app RAILS_TEST_DATABASE_NAME=app_test RAILS_DATABASE_USER=postgres RAILS_DATABASE_PASSWORD= To use it we need to modify our docker-compose.yml again version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db env_file: .env db: image: postgres:9.5.3 Safety Third If you haven’t already…Now is probably a good time to git init and make your initial commit. Dockerfile Part The-One-After-Deux Installing rails modified our Gemfile and Gemfile.lock. It also added all the files for a rails app - so we need to build the new image. In order to do that, our new Dockerfile should look like this: FROM ruby:2.3.1 WORKDIR /usr/src/app COPY Gemfile . COPY Gemfile.lock . RUN bundle install COPY . /usr/src/app now build it again ~/development/myapp $ docker-compose build Starting Postgres The first thing we need to do is create our database. In order to do that, we’re going to start our postgresql container thusly: ~/development/myapp $ docker-compose up -d db This command starts a postgres container in the background (-d) as defined by our db: service in our docker-compose.yml Creating The Database Now that we have a running postgres instance, we can create our development and test databases ~/development/myapp $ docker-compose run --rm app rake db:create If all goes well, it should simply return. On repeat invocations, you should get the following output: ~/development/myapp $ docker-compose run --rm app rake db:create app already exists app_test already exists ##Running The App To do this, we’re going to need to add a command and open some ports to our app: container. To do that, we’re going to modify our docker-compose file again: version: &quot;2&quot; services: app: build: context: . dockerfile: Dockerfile volumes: - .:/usr/src/app links: - db env_file: .env command: rails s -p 3000 -b 0.0.0.0 ports: - &quot;3000:3000&quot; db: image: postgres:9.5.3 This starts a server when we bring the container up, it also exposes port 3000 all the way to the host machine. To start the server, we run ~/development/myapp $ docker-compose up -d To find out where the app is running, you can use ~/development/myapp $ docker-machine ls NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS default * virtualbox Running tcp://192.168.99.100:2376 v1.10.2 ~/development/myapp $ docker-machine env default export DOCKER_TLS_VERIFY=&quot;1&quot; export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; export DOCKER_CERT_PATH=&quot;/Users/Scott/.docker/machine/machines/default&quot; export DOCKER_MACHINE_NAME=&quot;default&quot; That docker host ip is what we’re interested in. Now you should be able to open your browser to http://192.168.99.100:300 and see that lovely new rails app page. Next Time… The next article will be all about setting up rspec and guard","headline":"New Rails App With Docker","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/06/07/new-rails-app-with-docker.html"},"url":"/2016/06/07/new-rails-app-with-docker.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/rss.rss" title="Scott Helm" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest"></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Scott Helm</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/all_posts.html">All Posts</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">New Rails App With Docker</h1>
    <p class="post-meta"><time class="dt-published" datetime="2016-06-07T00:00:00-04:00" itemprop="datePublished">
        2016-06-07
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>There are a ton of posts out there on this topic. The purpose of this post is
to show the step-by-step creation of a new dockerized rails application, hooked
up to postgres. The next article in the series will show how to set up rspec and guard for your testing pleasure, and the final article in the series will highlight some tools that make development in docker an even more enjoyable experience.</p>

<h2 id="prerequisites">Prerequisites</h2>
<p>In order to follow along, you will need to install docker on your system. For
Mac and Windows,
<a href="https://www.docker.com/products/docker-toolbox">this link will get you started</a>.
If you are in a linux environment, you will need:</p>

<ul>
  <li><a href="https://docs.docker.com/linux/">Docker</a></li>
  <li><a href="https://docs.docker.com/machine/install-machine/">Docker Machine</a></li>
  <li><a href="https://docs.docker.com/compose/install/">Docker Compose</a></li>
</ul>

<p>Come back once you get it installed. I’ll wait.</p>

<h2 id="getting-started">Getting Started</h2>
<p>Cool. The first thing we’ll need is an empty directory. In order for mounted
volumes to play nicely, you’ll need to create this directory somewhere in your
home folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development $ mkdir myapp
~/development $ cd myapp
</code></pre></div></div>

<p>##The Gemfile
The next thing we’ll need is a Gemfile. This is where we’ll start setting up our development environment.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># frozen_string_literal: true
source 'https://rubygems.org'

gem 'rails'

group :development, :test do
  gem 'rspec-rails'
  gem 'guard-rspec'
  gem 'rubocop'
end
</code></pre></div></div>

<p>##The Dockerfile
Now that we have a Gemfile, we can start building our docker image. Docker works on the principal of linux containers, and uses a layered file system. A docker image is like a
photoshop image. You start with a base layer (in this case, it’s <code class="language-plaintext highlighter-rouge">ruby:latest</code>) and then we start layering our changes on top of it. Every command you see in the <code class="language-plaintext highlighter-rouge">Dockerfile</code> changes the file system in some way. Docker responds to this by creating another layer on top of the base image. In our first iteration of the Dockerfile, we specify that we want Ruby 2.3.1, and that we want our code to live in <code class="language-plaintext highlighter-rouge">/usr/src/app</code>. We set our working directory to that location and copy our gemfile into it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ruby:2.3.1

WORKDIR /usr/src/app

COPY Gemfile .
</code></pre></div></div>

<h1 id="the-docker-composeyml">The docker-compose.yml</h1>
<p>This file describes the services in our application. This will be an iterative process to build our application step-by step. Doing it this way, we don’t even have to have ruby installed on our system. The Docker image handles that for us.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: "2"
services:
  app:
    context:
      build: .
      dockerfile: Dockerfile
    volumes:
      - .:/usr/src/app
</code></pre></div></div>

<p>This file lets us specify that we have a service called <code class="language-plaintext highlighter-rouge">app</code>. We want to build an image for <code class="language-plaintext highlighter-rouge">app</code> using the current directory as the contents to layer on top of the base image. We want to use the Dockerfile that we created earlier, and we want to mount our current directory (in this case: <code class="language-plaintext highlighter-rouge">~/development/myapp</code>) to the /user/src/app directory in the container. We’ll get into the difference between an Docker image and a Docker container later.</p>

<h2 id="building-our-app-image">Building our app image</h2>
<p>So now that we have the rough-in of our plumbing done, we should be able to build the Docker image for our app. We can do this by using docker-compose:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose build
</code></pre></div></div>

<p>We should get some output like this (yours will probably need to pull the ruby base image down, so you will see some progress bars as this happens).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Building app
Step 1 : FROM ruby:2.3.1
 ---&gt; 316ceaa79560
Step 2 : WORKDIR /usr/src/app
 ---&gt; Running in 64c2cf1a6324
 ---&gt; f677d3669a90
Removing intermediate container 64c2cf1a6324
Step 3 : COPY Gemfile .
 ---&gt; 64cd3ad6bf21
Removing intermediate container 6b71f68d3fc7
Successfully built 64cd3ad6bf21
</code></pre></div></div>

<p>We now have a Docker image of our app that has our Gemfile in it. Now we need to install the gems.</p>

<h2 id="running-our-first-container">Running our first container</h2>
<p>You can think of the difference between an image and a container much like the difference between a class and an instance of a class. The image is the class. It is a full filesystem, and it has everthing needed for running your ruby process. However, it’s static. It is an image of a running system. The running system is a container. The container uses the image to run a single process. When that process ends, so does the container. Poetic, really. The first thing we are going to do is run a bash session so we can bundle our gems. Because our current directory is mounted as the volume <code class="language-plaintext highlighter-rouge">/usr/src/app</code> in the container, changes to that directory in the container are reflected in our host system. The <code class="language-plaintext highlighter-rouge">--rm</code> indicates that we want to remove the <code class="language-plaintext highlighter-rouge">app</code> container when the bash process ends.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose run --rm app /bin/bash
</code></pre></div></div>

<p>You should now be at a prompt as root in your new container:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating network "myapp_default" with the default driver
root@ff372d086cd0:/usr/src/app#
</code></pre></div></div>

<p>Here, we will run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ff372d086cd0:/usr/src/app# bundle install
</code></pre></div></div>

<p>This will install the gems from our <code class="language-plaintext highlighter-rouge">Gemfile</code> and create a new <code class="language-plaintext highlighter-rouge">Gemfile.lock</code> in the container AND on our host system. You should get the usual bundler output. type <code class="language-plaintext highlighter-rouge">exit</code> at the prompt and you should be back on the host system. If you <code class="language-plaintext highlighter-rouge">ls</code> you should now see a new file: <code class="language-plaintext highlighter-rouge">Gemfile.lock</code></p>

<h2 id="dockerfile-part-deux">Dockerfile Part Deux</h2>
<p>Now that we have a Gemfile.lock, we need to get that into our image. Additionally, we need to install the gems into the image. To do this, we need to modify our <code class="language-plaintext highlighter-rouge">Dockerfile</code> so the image has everything our container needs in order to install our rails app. The new dockerfile should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ruby:2.3.1

WORKDIR /usr/src/app

COPY Gemfile .
COPY Gemfile.lock .

RUN bundle install
</code></pre></div></div>

<p>Now we need to run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose build
</code></pre></div></div>

<p>again. This will install the gems into the image, and allow us to use them when we launch the image as a container</p>

<h2 id="docker-composeyml-part-deux">docker-compose.yml Part Deux</h2>
<p>We want to mimic our production environment, so we want to use Postgresql as our database. Turns out, Postgresql has an official image that we can use - so let’s add it as a service and link it to our app in our <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: "2"
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/usr/src/app
    links:
      - db
  db:
    image: postgres:9.5.3
</code></pre></div></div>

<h2 id="installing-rails">Installing Rails</h2>
<p>Start a new container using</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose run --rm app /bin/bash
</code></pre></div></div>

<p>Now that we’re back inside the container, we can install rails with Postgres as the database, and skipping tests (we’ll set up rspec in a minute):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@5ff8a0519772:/usr/src/app# rails new -T --database=postgresql .
</code></pre></div></div>

<p>You’ll be prompted to overwrite your Gemfile…type Y. You’ll also be warned not to run bundler as root. Ignore that since this is a container, and the only user is root! Once that’s done, you can <code class="language-plaintext highlighter-rouge">exit</code> out of the container, and you should have all the files for a new Rails application in your host directory.</p>

<p>There’s a couple of other modifications we’ll need to make. We’ll need a javascript runtime, so we can uncomment <code class="language-plaintext highlighter-rouge">gem 'therubyracer'</code> in the Gemfile. Wel’ll also need to set up our database connections in our <code class="language-plaintext highlighter-rouge">config/database.yml</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>development:
  &lt;&lt;: *default
  host: db
  database: &lt;%= ENV['RAILS_DATABASE_NAME'] %&gt;
  username: &lt;%= ENV['RAILS_DATABASE_USER'] %&gt;
  password: &lt;%= ENV['RAILS_DATABASE_PASSWORD'] %&gt;
test:
&lt;&lt;: *default
  host: db
  database: &lt;%= ENV['RAILS_TEST_DATABASE_NAME'] %&gt;
  username: &lt;%= ENV['RAILS_DATABASE_USER'] %&gt;
  password: &lt;%= ENV['RAILS_DATABASE_PASSWORD'] %&gt;
</code></pre></div></div>

<p>“Wait…” I hear you say. “Where do those environment variables come from?” I’m glad you asked:</p>

<h2 id="environment-variables">Environment Variables</h2>
<p>The easiest way to accomplish this is with a <code class="language-plaintext highlighter-rouge">.env</code> file. This file can be git ignored so it never hits your remote repo, but still has your super secret username/password stuff. It has this format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RAILS_DATABASE_NAME=app
RAILS_TEST_DATABASE_NAME=app_test
RAILS_DATABASE_USER=postgres
RAILS_DATABASE_PASSWORD=
</code></pre></div></div>

<p>To use it we need to modify our <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> again</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: "2"
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/usr/src/app
    links:
      - db
    env_file: .env
  db:
    image: postgres:9.5.3
</code></pre></div></div>

<h2 id="safety-third">Safety Third</h2>
<p>If you haven’t already…Now is probably a good time to <code class="language-plaintext highlighter-rouge">git init</code> and make your initial commit.</p>

<h2 id="dockerfile-part-the-one-after-deux">Dockerfile Part The-One-After-Deux</h2>
<p>Installing rails modified our Gemfile and Gemfile.lock. It also added all the files for a rails app - so we need to build the new image. In order to do that, our new <code class="language-plaintext highlighter-rouge">Dockerfile</code> should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ruby:2.3.1

WORKDIR /usr/src/app

COPY Gemfile .
COPY Gemfile.lock .

RUN bundle install

COPY . /usr/src/app
</code></pre></div></div>

<p>now build it again</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose build
</code></pre></div></div>

<h2 id="starting-postgres">Starting Postgres</h2>
<p>The first thing we need to do is create our database. In order to do that, we’re going to start our postgresql container thusly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose up -d db
</code></pre></div></div>

<p>This command starts a postgres container in the background (-d) as defined by our <code class="language-plaintext highlighter-rouge">db:</code> service in our <code class="language-plaintext highlighter-rouge">docker-compose.yml</code></p>

<h2 id="creating-the-database">Creating The Database</h2>
<p>Now that we have a running postgres instance, we can create our development and test databases</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose run --rm app rake db:create
</code></pre></div></div>

<p>If all goes well, it should simply return. On repeat invocations, you should get the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose run --rm app rake db:create
app already exists
app_test already exists
</code></pre></div></div>

<p>##Running The App
To do this, we’re going to need to add a command and open some ports to our <code class="language-plaintext highlighter-rouge">app:</code> container. To do that, we’re going to modify our docker-compose file again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: "2"
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/usr/src/app
    links:
      - db
    env_file: .env
    command: rails s -p 3000 -b 0.0.0.0
    ports:
      - "3000:3000"
  db:
    image: postgres:9.5.3
</code></pre></div></div>

<p>This starts a server when we bring the container up, it also exposes port 3000 all the way to the host machine. To start the server, we run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-compose up -d
</code></pre></div></div>

<p>To find out where the app is running, you can use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/development/myapp $ docker-machine ls
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER    ERRORS
default    *        virtualbox   Running   tcp://192.168.99.100:2376           v1.10.2

~/development/myapp $ docker-machine env default
export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://192.168.99.100:2376"
export DOCKER_CERT_PATH="/Users/Scott/.docker/machine/machines/default"
export DOCKER_MACHINE_NAME="default"
</code></pre></div></div>

<p>That docker host ip is what we’re interested in. Now you should be able to open your browser to <code class="language-plaintext highlighter-rouge">http://192.168.99.100:300</code> and see that lovely new rails app page.</p>

<h2 id="next-time">Next Time…</h2>
<p>The next article will be all about setting up rspec and guard</p>

  </div><a class="u-url" href="/2016/06/07/new-rails-app-with-docker.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/rss.rss">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">&copy; Scott Helm 2023</li>
          
        </ul>
      </div>
      <div class="footer-col">
        <p>Father, Husband, Technologist, Actor, Musician, Life-long Learner</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a rel="me" href="https://github.com/scotthelm" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://linkedin.com/in/scott-helm-4a1aa52" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://stackoverflow.com/users/1518852/plasticide" target="_blank" title="stackoverflow">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/scott_helm" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
